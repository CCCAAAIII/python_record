<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->

- [python基础](#python基础)
	- [1. python中的参数传递](#1-python中的参数传递)
	- [2. 元类](#2-元类)
	- [3. python中的静态方法和类方法和实例方法](#3-python中的静态方法和类方法和实例方法)
	- [4. 类变量和实例变量](#4-类变量和实例变量)
	- [5. python自省](#5-python自省)
	- [6. 字典推导式](#6-字典推导式)
	- [7. python 中单下划线和双下划线](#7-python-中单下划线和双下划线)
	- [8. python中字符串格式化`%s`和`format`](#8-python中字符串格式化s和format)
	- [9.迭代器和生成器](#9迭代器和生成器)
	- [10.  *args and **kwargs](#10-args-and-kwargs)
	- [11. 面向切面编程AOP和装饰器](#11-面向切面编程aop和装饰器)
	- [12.鸭子类型](#12鸭子类型)
	- [13. python中的重载](#13-python中的重载)
	- [14. 新式类和旧式类](#14-新式类和旧式类)
	- [15. __new__和__init__的区别](#15-new和init的区别)
	- [16. 单例模式](#16-单例模式)
	- [17. python中的作用域](#17-python中的作用域)
	- [18. GIL global interpreter lock 全局解释锁](#18-gil-global-interpreter-lock-全局解释锁)
	- [19. 协程](#19-协程)
	- [20. 闭包](#20-闭包)
	- [21.lambda函数](#21lambda函数)
	- [22. 函数式编程](#22-函数式编程)
	- [23.python 里的复制浅拷贝深拷贝](#23python-里的复制浅拷贝深拷贝)
	- [24. python 垃圾回收机制](#24-python-垃圾回收机制)

<!-- /TOC -->
# python基础

## 1. python中的参数传递
变量没有类型，有类型的是对象，
在python中有可变类型和不可变类型，当传递的是不可变类型时，不会对外面的变量产生影响，当传递的是可变类型时

对于不可变对象作为函数参数，相当于C系语言的值传递；
对于可变对象作为函数参数，且参数不指向其他对象时，相当于C系语言的引用传递。
对于可变对象作为函数参数，参数指向其他对象，对参数变量的操作不影响原变量的值
## 2. 元类
元类就是类的类，python中的type可以动态的创建类，元类用于拦截类的创建
## 3. python中的静态方法和类方法和实例方法
1. 静态方法 对参数没有要求 是普通函数，位于类的命名空间，对象和类都可以调用
2. 实例方法 实例方法属于实例，由实例调用,一般第一个参数使用self
3. 类方法 类方法属于类，实例和类都可以调用，一般第一个参数使用cls

## 4. 类变量和实例变量
类变量就是类使用的变量
实例变量就是实例使用的变量
## 5. python自省
自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance().
## 6. 字典推导式
推导式是可以从一个数据序列构建另一个新的数据序列的结构体
1. 列表推导式
[表达式 for 变量 in 列表]或者[表达式 for 变量 in 列表 if 条件]
2. 字典推导式
{ key_expr: value_expr for value in collection if condition }
`{key:len(key) for i in range(10) if i>2}`
3. 集合推导式
`{ expr for value in collection if condition }`

## 7. python 中单下划线和双下划线
- `__foo__` python中约定内部的名字
- `_foo` 保护成员
- `__foo`私有成员

## 8. python中字符串格式化`%s`和`format`
format格式化字符串比较方便，%s如果`‘a%s’%（1,2,3）`会报错 需要加上括号
## 9.迭代器和生成器
迭代是python最强大的功能之一，是访问集合的一种方式
- 迭代器是一个可以记住遍历的位置的对象，迭代器对象从集合的第一个元素开始访问，
直到所有的元素被访问结束，迭代器只能前进，不会后退
迭代器有两个基本的方法，iter()和next()可以被next()函数调用并不断返回下一个值
的对象称为迭代器：Iterator。

- 可迭代类型：这些可以直接作用于for循环的对象统称为可迭代对象：Iterable，
可以使用isinstance()判断一个对象是否是Iterable对象
- 在Python中，这种一边循环一边计算的机制，称为生成器：generator。

## 10.  *args and **kwargs
当不确定参数个数时可以使用可变长参数
- *args 元组类型
- **kwargs 字典类型

## 11. 面向切面编程AOP和装饰器
- 面向切面编程AOP：在运行时，编译时，类和方法加载时，
动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。
优点：对原有代码毫无入侵性
- 装饰器：有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。
概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。
装饰器使函数调用变慢了，django用装饰器管理换成和视图函数的权限
## 12.鸭子类型
是一种对象推断风格
一只鸟走起来像鸭子、游起泳来像鸭子、叫起来也像鸭子，那它就可以被当做鸭子。也就是说，它不关注对象的类型，而是关注对象具有的行为(方法)。
我们并不关心对象是什么类型，到底是不是鸭子，只关心行为。
比如在python中，有很多file-like的东西，比如StringIO,GzipFile,socket。它们有很多相同的方法，我们把它们当作文件使用。
又比如list.extend()方法中,我们并不关心它的参数是不是list,只要它是可迭代的,所以它的参数可以是list/tuple/dict/字符串/生成器等.
## 13. python中的重载
重载的两个特征：可变参数类型，可变参数个数，像c++等强类型语言中是有重载的，但是在python中，python
本身是弱类型语言，类型本身就可变，另外python支持可变长参数，所以，python不需要重载
## 14. 新式类和旧式类
在python3中取消了经典类，不管写的时候继不继承object都会默认继承
python2中默认是经典类，只有显式继承了object才是新式类
区别：继承搜索的顺序发生了改变，经典类多继承搜索顺序是深度优先，新式类是广度优先，现在水平方向搜索

## 15. __new__和__init__的区别
1. __new__是一个静态方法,而__init__是一个实例方法.
2. __new__方法会返回一个创建的实例,而__init__什么都不返回.
3. 只有在__new__返回一个cls的实例时后面的__init__才能被调用.
4. 当创建一个新实例时调用__new__,初始化一个实例时用__init__.

ps: __metaclass__是创建类时起作用.所以我们可以分别使用
__metaclass__,__new__和__init__来分别在类创建,实例创建和实例初始化的时候做一些小手脚.
## 16. 单例模式
目的：确定某个类只有一个实例出现
实现模式的方法：
1. 使用模块，python的模块是天然的单例模式，放到一个模块里
2. 使用装饰器
3. 基于__new__方法实现
4. 使用元类实现

## 17. python中的作用域
Python 使用 LEGB 的顺序来查找一个符号对应的对象
- locals，当前所在命名空间（如函数、模块），函数的参数也属于命名空间内的变量
- enclosing，外部嵌套函数的命名空间（闭包中常见）
- globals，全局变量，函数定义所在模块的命名空间
- builtins，内建模块的命名空间。

## 18. GIL global interpreter lock 全局解释锁
产生这个锁的原因是cpython在执行多线程时不安全所以为了保证线程安全，一个核
在同一时间只能运行一个线程，对计算密集型的程序影响比较大，解决办法是多进程和协程
## 19. 协程
Python对协程的支持是通过generator实现的
简单来说协程是进程和线程的升级版，线程和进程都面临着管态和目态切换而耗费时间
的问题，协程就是用户自己控制切换时机不用陷入管态
1. Python对协程的支持是通过generator实现的
## 20. 闭包
闭包是一种代码组织结构，提高了代码的重用性
1. 有内嵌函数
2. 内嵌函数引用外部变量
3. 外部函数返回内部函数的引用
## 21.lambda函数
匿名函数
## 22. 函数式编程
函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言
编写的函数没有变量，因此，任意一个函数，只要输入是确定的，
输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用
变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，
可能得到不同的输出，因此，这种函数是有副作用的。
函数式编程的一个特点就是，允许把函数本身作为参数传入
另一个函数，还允许返回一个函数
filter,map,reduce
## 23.python 里的复制浅拷贝深拷贝
- 复制，就是直接复制引用
- 浅拷贝，为对象开辟了新的空间，但是内层可变类型的引用还是指向原来的，
- 深拷贝 开辟新空间，内层可变类型也会为其开新的空间，和原来是两个完全独立的个体
## 24. python 垃圾回收机制
1. 引用计数
2. 标记清除
3. 分代
